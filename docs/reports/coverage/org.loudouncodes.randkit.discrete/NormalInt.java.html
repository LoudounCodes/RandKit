<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>NormalInt.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">randkit</a> &gt; <a href="index.source.html" class="el_package">org.loudouncodes.randkit.discrete</a> &gt; <span class="el_source">NormalInt.java</span></div><h1>NormalInt.java</h1><pre class="source lang-java linenums">package org.loudouncodes.randkit.discrete;

import java.util.random.RandomGenerator;
import org.loudouncodes.randkit.api.DiscreteDistribution;
import org.loudouncodes.randkit.api.DistributionSupport;
import org.loudouncodes.randkit.util.Randoms;

/**
 * A &lt;em&gt;discrete normal&lt;/em&gt; (rounded-normal) distribution on the integers.
 *
 * &lt;p&gt;This distribution is constructed by sampling a continuous normal {@code X ~ Normal(mean,
 * sigma^2)} and returning the integer {@code Y = round(X)} (nearest-even rounding via {@link
 * Math#rint(double)}). It therefore places probability mass on all integers (unless truncated).
 *
 * &lt;h2&gt;Probability functions&lt;/h2&gt;
 *
 * &lt;p&gt;For the &lt;strong&gt;untruncated&lt;/strong&gt; rounded-normal, the probability mass function (PMF) and
 * cumulative distribution function (CDF) are exact:
 *
 * &lt;pre&gt;{@code
 * pmf(k) = Φ((k + 0.5 - mean)/sigma) - Φ((k - 0.5 - mean)/sigma)
 * cdf(k) = Φ((k + 0.5 - mean)/sigma)
 * }&lt;/pre&gt;
 *
 * where {@code Φ} is the standard normal CDF.
 *
 * &lt;p&gt;For the &lt;strong&gt;truncated&lt;/strong&gt; variant on {@code [lower, upper]} (inclusive), mass is
 * re-normalized to that interval:
 *
 * &lt;pre&gt;{@code
 * Z = Φ((upper + 0.5 - mean)/sigma) - Φ((lower - 0.5 - mean)/sigma)
 * pmf_trunc(k) = pmf(k) / Z     for k in [lower, upper], else 0
 * cdf_trunc(k) = (Φ((k + 0.5 - mean)/sigma) - Φ((lower - 0.5 - mean)/sigma)) / Z
 * }&lt;/pre&gt;
 *
 * &lt;h2&gt;Sampling&lt;/h2&gt;
 *
 * &lt;p&gt;Sampling uses the Marsaglia polar (Box–Muller) method to draw a standard normal, then
 * scales/shifts and applies nearest-even rounding. When truncated, out-of-range draws are rejected
 * and re-sampled (efficient unless the window is deep in the tails).
 *
 * &lt;h2&gt;Numerics&lt;/h2&gt;
 *
 * &lt;ul&gt;
 *   &lt;li&gt;{@code Φ} is computed via an {@code erf} approximation (Abramowitz &amp;amp; Stegun 7.1.26),
 *       with max absolute error ≈ 1.5e−7.
 *   &lt;li&gt;Untruncated mean/variance are computed by summing the PMF over a wide {@code ±8σ} window
 *       (extended until the remaining tail mass is negligible).
 * &lt;/ul&gt;
 *
 * &lt;h2&gt;Determinism &amp;amp; threading&lt;/h2&gt;
 *
 * &lt;p&gt;Given the same seed, parameters, and JDK RNG algorithm, sequences are repeatable. Instances
 * are not synchronized; prefer one instance per thread or supply thread-local RNGs.
 *
 * &lt;h2&gt;Examples&lt;/h2&gt;
 *
 * &lt;pre&gt;{@code
 * // Untruncated discrete normal centered near 2, σ = 1.5
 * var d1 = new NormalInt(2.0, 1.5);
 * int x = d1.sample();
 *
 * // Seeded and truncated to [-3, +3]
 * var d2 = new NormalInt(1234L, 0.0, 2.0, -3, 3);
 * double p0 = d2.pmf(0);      // probability at 0
 * double F2 = d2.cdf(2);      // P(Y &lt;= 2)
 * }&lt;/pre&gt;
 *
 * @since 0.1.0
 */
public final class NormalInt implements DiscreteDistribution {

  /** RNG supplying uniform bits; provided or created via {@link Randoms}. */
  private final RandomGenerator rng;

  /** Mean {@code μ} of the underlying continuous normal. */
  private final double meanParam;

  /** Standard deviation {@code σ} of the underlying continuous normal (must be {@code &gt; 0}). */
  private final double sigma;

  // Truncation metadata (active when 'truncated' is true).
  private final boolean truncated;
  private final int lower;
  private final int upper;
  private final double normZ; // normalization constant for truncated mass
  private final boolean degenerate; // when truncation window has ~zero mass
  private final int degenerateValue;

  // Cached moments reported by the API.
  private final double meanCached;
  private final double varianceCached;

  // Box–Muller (polar) spare sample caching.
<span class="fc" id="L95">  private boolean haveSpare = false;</span>
<span class="fc" id="L96">  private double spare = 0.0;</span>

<span class="fc" id="L98">  private static final double INV_SQRT2 = 1.0 / Math.sqrt(2.0);</span>

  // ---------- Constructors (untruncated) ----------

  /**
   * Creates an untruncated discrete normal using the library's default RNG.
   *
   * @param mean the mean {@code μ} of the underlying continuous normal (finite)
   * @param sigma the standard deviation {@code σ} of the underlying normal; must be {@code &gt; 0}
   * @throws IllegalArgumentException if {@code mean} is not finite or {@code sigma &lt;= 0} or not
   *     finite
   */
  public NormalInt(double mean, double sigma) {
<span class="nc" id="L111">    this(Randoms.defaultGenerator(), mean, sigma);</span>
<span class="nc" id="L112">  }</span>

  /**
   * Creates an untruncated discrete normal with a deterministic RNG built from {@code seed}.
   *
   * @param seed RNG seed for reproducible sampling
   * @param mean the mean {@code μ} of the underlying continuous normal (finite)
   * @param sigma the standard deviation {@code σ} of the underlying normal; must be {@code &gt; 0}
   * @throws IllegalArgumentException if {@code mean} is not finite or {@code sigma &lt;= 0} or not
   *     finite
   */
  public NormalInt(long seed, double mean, double sigma) {
<span class="fc" id="L124">    this(Randoms.seeded(seed), mean, sigma);</span>
<span class="fc" id="L125">  }</span>

  /**
   * Creates an untruncated discrete normal with a caller-supplied RNG.
   *
   * @param rng the random generator (must not be {@code null})
   * @param mean the mean {@code μ} of the underlying continuous normal (finite)
   * @param sigma the standard deviation {@code σ} of the underlying normal; must be {@code &gt; 0}
   * @throws NullPointerException if {@code rng} is {@code null}
   * @throws IllegalArgumentException if {@code mean} is not finite or {@code sigma &lt;= 0} or not
   *     finite
   */
<span class="fc" id="L137">  public NormalInt(RandomGenerator rng, double mean, double sigma) {</span>
<span class="fc" id="L138">    validateParams(mean, sigma);</span>
<span class="pc bpc" id="L139" title="1 of 2 branches missed.">    if (rng == null) throw new NullPointerException(&quot;rng must not be null&quot;);</span>

<span class="fc" id="L141">    this.rng = rng;</span>
<span class="fc" id="L142">    this.meanParam = mean;</span>
<span class="fc" id="L143">    this.sigma = sigma;</span>

<span class="fc" id="L145">    this.truncated = false;</span>
<span class="fc" id="L146">    this.lower = Integer.MIN_VALUE;</span>
<span class="fc" id="L147">    this.upper = Integer.MAX_VALUE;</span>
<span class="fc" id="L148">    this.normZ = 1.0;</span>
<span class="fc" id="L149">    this.degenerate = false;</span>
<span class="fc" id="L150">    this.degenerateValue = (int) Math.rint(meanParam);</span>

<span class="fc" id="L152">    double[] m = computeUntruncatedMoments();</span>
<span class="fc" id="L153">    this.meanCached = m[0];</span>
<span class="fc" id="L154">    this.varianceCached = m[1];</span>
<span class="fc" id="L155">  }</span>

  // ---------- Constructors (truncated) ----------

  /**
   * Creates a truncated discrete normal on the closed interval {@code [lower, upper]} using the
   * library's default RNG. Mass is re-normalized to the interval.
   *
   * @param mean the mean {@code μ} of the underlying continuous normal (finite)
   * @param sigma the standard deviation {@code σ} of the underlying normal; must be {@code &gt; 0}
   * @param lower inclusive lower bound for the integer outcomes
   * @param upper inclusive upper bound for the integer outcomes; must be {@code &gt;= lower}
   * @throws IllegalArgumentException if parameters are invalid or {@code lower &gt; upper}
   */
  public NormalInt(double mean, double sigma, int lower, int upper) {
<span class="nc" id="L170">    this(Randoms.defaultGenerator(), mean, sigma, lower, upper);</span>
<span class="nc" id="L171">  }</span>

  /**
   * Creates a truncated discrete normal on {@code [lower, upper]} with a deterministic RNG.
   *
   * @param seed RNG seed for reproducible sampling
   * @param mean the mean {@code μ} of the underlying continuous normal (finite)
   * @param sigma the standard deviation {@code σ} of the underlying normal; must be {@code &gt; 0}
   * @param lower inclusive lower bound for the integer outcomes
   * @param upper inclusive upper bound for the integer outcomes; must be {@code &gt;= lower}
   * @throws IllegalArgumentException if parameters are invalid or {@code lower &gt; upper}
   */
  public NormalInt(long seed, double mean, double sigma, int lower, int upper) {
<span class="fc" id="L184">    this(Randoms.seeded(seed), mean, sigma, lower, upper);</span>
<span class="fc" id="L185">  }</span>

  /**
   * Creates a truncated discrete normal on {@code [lower, upper]} with a caller-supplied RNG.
   *
   * @param rng the random generator (must not be {@code null})
   * @param mean the mean {@code μ} of the underlying continuous normal (finite)
   * @param sigma the standard deviation {@code σ} of the underlying normal; must be {@code &gt; 0}
   * @param lower inclusive lower bound for the integer outcomes
   * @param upper inclusive upper bound for the integer outcomes; must be {@code &gt;= lower}
   * @throws NullPointerException if {@code rng} is {@code null}
   * @throws IllegalArgumentException if parameters are invalid or {@code lower &gt; upper}
   */
<span class="fc" id="L198">  public NormalInt(RandomGenerator rng, double mean, double sigma, int lower, int upper) {</span>
<span class="fc" id="L199">    validateParams(mean, sigma);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">    if (rng == null) throw new NullPointerException(&quot;rng must not be null&quot;);</span>
<span class="fc bfc" id="L201" title="All 2 branches covered.">    if (lower &gt; upper) {</span>
<span class="fc" id="L202">      throw new IllegalArgumentException(</span>
          &quot;lower must be &lt;= upper (got &quot; + lower + &quot; &gt; &quot; + upper + &quot;)&quot;);
    }

<span class="fc" id="L206">    this.rng = rng;</span>
<span class="fc" id="L207">    this.meanParam = mean;</span>
<span class="fc" id="L208">    this.sigma = sigma;</span>
<span class="fc" id="L209">    this.truncated = true;</span>
<span class="fc" id="L210">    this.lower = lower;</span>
<span class="fc" id="L211">    this.upper = upper;</span>

    // Normalization mass over the truncated support:
    // Z = P(Y in [lower, upper]) = Φ(upper+0.5) - Φ(lower-0.5)
<span class="fc" id="L215">    double zUpper = normalCdf(upper + 0.5);</span>
<span class="fc" id="L216">    double zLower = normalCdf(lower - 0.5);</span>
<span class="fc" id="L217">    double z = zUpper - zLower;</span>
<span class="fc" id="L218">    this.normZ = z;</span>

<span class="pc bpc" id="L220" title="1 of 2 branches missed.">    if (!(z &gt; 0.0)) {</span>
      // Window captures (numerically) no mass: become a point-mass at the
      // rounded mean, clamped to [lower, upper].
<span class="nc" id="L223">      this.degenerate = true;</span>
<span class="nc" id="L224">      int k = (int) Math.rint(meanParam);</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">      if (k &lt; lower) k = lower;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">      if (k &gt; upper) k = upper;</span>
<span class="nc" id="L227">      this.degenerateValue = k;</span>
<span class="nc" id="L228">      this.meanCached = k;</span>
<span class="nc" id="L229">      this.varianceCached = 0.0;</span>
<span class="nc" id="L230">    } else {</span>
<span class="fc" id="L231">      this.degenerate = false;</span>
<span class="fc" id="L232">      this.degenerateValue = (int) Math.rint(meanParam);</span>
<span class="fc" id="L233">      double[] mv = computeTruncatedMoments(lower, upper, z);</span>
<span class="fc" id="L234">      this.meanCached = mv[0];</span>
<span class="fc" id="L235">      this.varianceCached = mv[1];</span>
    }
<span class="fc" id="L237">  }</span>

  // ---------- API (DiscreteDistribution) ----------

  /**
   * Draws a single sample {@code Y} from this distribution.
   *
   * &lt;p&gt;For untruncated distributions, this value can be any integer (with quickly decaying tails).
   * For truncated distributions, the result is guaranteed to lie in {@code [lower, upper]}.
   *
   * @return a random integer variate
   */
  @Override
  public int sample() {
<span class="pc bpc" id="L251" title="1 of 2 branches missed.">    if (degenerate) return degenerateValue;</span>

    while (true) {
      // Draw a Normal(mean, sigma^2)
<span class="fc" id="L255">      double g = meanParam + sigma * nextGaussian();</span>
<span class="fc" id="L256">      int y = (int) Math.rint(g); // nearest-even rounding</span>
<span class="fc bfc" id="L257" title="All 6 branches covered.">      if (!truncated || (y &gt;= lower &amp;&amp; y &lt;= upper)) {</span>
<span class="fc" id="L258">        return y;</span>
      }
      // else reject and resample
<span class="fc" id="L261">    }</span>
  }

  /**
   * Returns the probability mass at {@code k}, i.e., {@code P(Y = k)}.
   *
   * @param k integer at which to evaluate the PMF
   * @return the probability mass at {@code k} (zero if truncated and {@code k} is outside the
   *     bounds)
   */
  @Override
  public double pmf(int k) {
<span class="pc bpc" id="L273" title="1 of 2 branches missed.">    if (degenerate) {</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">      return (k == degenerateValue) ? 1.0 : 0.0;</span>
    }
<span class="pc bpc" id="L276" title="2 of 6 branches missed.">    if (truncated &amp;&amp; (k &lt; lower || k &gt; upper)) return 0.0;</span>

<span class="fc" id="L278">    double p = pmfUntruncated(k);</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">    return truncated ? p / normZ : p;</span>
  }

  /**
   * Returns the cumulative distribution function at {@code k}, i.e., {@code P(Y ≤ k)}.
   *
   * @param k integer at which to evaluate the CDF
   * @return the cumulative probability at {@code k}
   */
  @Override
  public double cdf(int k) {
<span class="pc bpc" id="L290" title="1 of 2 branches missed.">    if (degenerate) {</span>
<span class="nc bnc" id="L291" title="All 2 branches missed.">      return (k &lt; degenerateValue) ? 0.0 : 1.0;</span>
    }
<span class="fc bfc" id="L293" title="All 2 branches covered.">    if (!truncated) return cdfUntruncated(k);</span>

<span class="pc bpc" id="L295" title="1 of 2 branches missed.">    if (k &lt; lower - 1) return 0.0;</span>
<span class="fc bfc" id="L296" title="All 2 branches covered.">    if (k &gt;= upper) return 1.0;</span>

    // For truncated: (Φ(k+0.5) - Φ(lower-0.5)) / Z
<span class="fc" id="L299">    double num = normalCdf(k + 0.5) - normalCdf(lower - 0.5);</span>
<span class="fc" id="L300">    return num / normZ;</span>
  }

  /**
   * Returns the distribution mean (expected value).
   *
   * &lt;p&gt;For the rounded-normal, this is close to {@code mean}, with a tiny quantization effect. For
   * the truncated variant, this is the re-normalized mean over the interval.
   *
   * @return {@code E[Y]}
   */
  @Override
  public double mean() {
<span class="fc" id="L313">    return meanCached;</span>
  }

  /**
   * Returns the distribution variance.
   *
   * &lt;p&gt;For the rounded-normal, this is close to {@code sigma^2} plus a small quantization effect.
   * For the truncated variant, this is the re-normalized variance over the interval.
   *
   * @return {@code Var[Y]}
   */
  @Override
  public double variance() {
<span class="fc" id="L326">    return varianceCached;</span>
  }

  /**
   * Reports the mathematical support (domain) of this distribution.
   *
   * &lt;p&gt;For untruncated instances the support is the unbounded integer line. For truncated instances
   * it is the closed interval {@code [lower, upper]}.
   *
   * @return a {@link DistributionSupport} describing the support (discrete)
   */
  public DistributionSupport support() {
<span class="fc bfc" id="L338" title="All 2 branches covered.">    if (!truncated) {</span>
<span class="fc" id="L339">      return DistributionSupport.discrete(</span>
          Double.NEGATIVE_INFINITY, false,
          Double.POSITIVE_INFINITY, false);
    }
<span class="fc" id="L343">    return DistributionSupport.discrete(lower, true, upper, true);</span>
  }

  // ---------- Internal helpers ----------

  /**
   * Validates constructor parameters.
   *
   * @param mean the mean parameter (finite)
   * @param sigma the standard deviation parameter (finite and {@code &gt; 0})
   * @throws IllegalArgumentException if parameters are invalid
   */
  private static void validateParams(double mean, double sigma) {
<span class="fc bfc" id="L356" title="All 2 branches covered.">    if (!Double.isFinite(mean)) throw new IllegalArgumentException(&quot;mean must be finite&quot;);</span>
<span class="fc bfc" id="L357" title="All 4 branches covered.">    if (!Double.isFinite(sigma) || !(sigma &gt; 0.0)) {</span>
<span class="fc" id="L358">      throw new IllegalArgumentException(&quot;sigma must be finite and &gt; 0&quot;);</span>
    }
<span class="fc" id="L360">  }</span>

  /**
   * PMF for the &lt;em&gt;untruncated&lt;/em&gt; rounded-normal at integer {@code k}.
   *
   * @param k integer support point
   * @return {@code P(Y = k)} before any truncation is applied
   */
  private double pmfUntruncated(int k) {
<span class="fc" id="L369">    double a = normalCdf(k + 0.5);</span>
<span class="fc" id="L370">    double b = normalCdf(k - 0.5);</span>
<span class="fc" id="L371">    double p = a - b;</span>
<span class="pc bpc" id="L372" title="1 of 2 branches missed.">    return (p &lt;= 0.0) ? 0.0 : p; // guard against tiny negatives from roundoff</span>
  }

  /**
   * CDF for the &lt;em&gt;untruncated&lt;/em&gt; rounded-normal at integer {@code k}.
   *
   * @param k integer support point
   * @return {@code P(Y ≤ k)} before any truncation is applied
   */
  private double cdfUntruncated(int k) {
<span class="fc" id="L382">    return normalCdf(k + 0.5);</span>
  }

  /**
   * Standard normal CDF {@code Φ(x)} using an {@code erf} approximation (no dependency on {@code
   * Math.erf} for broad JDK compatibility).
   *
   * @param x standardized value
   * @return {@code Φ(x)}
   */
  private double normalCdf(double x) {
<span class="fc" id="L393">    double z = (x - meanParam) / sigma;</span>
<span class="fc" id="L394">    return 0.5 * (1.0 + erfApprox(z * INV_SQRT2));</span>
  }

  /**
   * Approximation to {@code erf(x)} with max absolute error ≈ 1.5e−7.
   *
   * &lt;p&gt;From Abramowitz &amp;amp; Stegun 7.1.26 (Horner form).
   *
   * @param x input
   * @return approximate {@code erf(x)}
   */
  private static double erfApprox(double x) {
<span class="fc" id="L406">    double sign = Math.signum(x);</span>
<span class="fc" id="L407">    double ax = Math.abs(x);</span>
<span class="fc" id="L408">    double t = 1.0 / (1.0 + 0.3275911 * ax);</span>
<span class="fc" id="L409">    double y =</span>
        1.0
            - (((((1.061405429 * t - 1.453152027) * t) + 1.421413741) * t - 0.284496736) * t
                    + 0.254829592)
                * t
<span class="fc" id="L414">                * Math.exp(-ax * ax);</span>
<span class="fc" id="L415">    return sign * y;</span>
  }

  /**
   * Computes mean and variance for the &lt;em&gt;untruncated&lt;/em&gt; rounded-normal by summing a wide window
   * of integer support (starting at {@code ±8σ} and expanding if tiny tail mass remains).
   *
   * @return array {@code [mean, variance]}
   */
  private double[] computeUntruncatedMoments() {
<span class="fc" id="L425">    int a = (int) Math.floor(meanParam - 8.0 * sigma);</span>
<span class="fc" id="L426">    int b = (int) Math.ceil(meanParam + 8.0 * sigma);</span>

<span class="fc" id="L428">    double mass = 0.0, m1 = 0.0, m2 = 0.0;</span>

<span class="fc bfc" id="L430" title="All 2 branches covered.">    for (int k = a; k &lt;= b; k++) {</span>
<span class="fc" id="L431">      double p = pmfUntruncated(k);</span>
<span class="fc" id="L432">      mass += p;</span>
<span class="fc" id="L433">      m1 += p * k;</span>
<span class="fc" id="L434">      m2 += p * (double) k * (double) k;</span>
    }

<span class="fc" id="L437">    int extend = 0;</span>
<span class="pc bpc" id="L438" title="3 of 4 branches missed.">    while (mass &lt; 1.0 - 1e-12 &amp;&amp; extend &lt; 32) {</span>
<span class="nc" id="L439">      a -= 1;</span>
<span class="nc" id="L440">      b += 1;</span>
<span class="nc" id="L441">      double pLeft = pmfUntruncated(a);</span>
<span class="nc" id="L442">      double pRight = pmfUntruncated(b);</span>
<span class="nc" id="L443">      mass += pLeft + pRight;</span>
<span class="nc" id="L444">      m1 += pLeft * a + pRight * b;</span>
<span class="nc" id="L445">      m2 += pLeft * (double) a * (double) a + pRight * (double) b * (double) b;</span>
<span class="nc" id="L446">      extend++;</span>
<span class="nc" id="L447">    }</span>

<span class="pc bpc" id="L449" title="2 of 4 branches missed.">    if (mass &gt; 0.0 &amp;&amp; Math.abs(1.0 - mass) &gt; 1e-15) {</span>
<span class="nc" id="L450">      m1 /= mass;</span>
<span class="nc" id="L451">      m2 /= mass;</span>
    }
<span class="fc" id="L453">    double var = m2 - m1 * m1;</span>
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">    if (var &lt; 0.0) var = 0.0; // numeric guard</span>
<span class="fc" id="L455">    return new double[] {m1, var};</span>
  }

  /**
   * Computes mean and variance for the &lt;em&gt;truncated&lt;/em&gt; rounded-normal by summing exactly over
   * {@code k = lower..upper} with the renormalization constant {@code Z}.
   *
   * @param lower inclusive lower bound
   * @param upper inclusive upper bound
   * @param z renormalization constant {@code Z = P(lower ≤ Y ≤ upper)}
   * @return array {@code [mean, variance]}
   */
  private double[] computeTruncatedMoments(int lower, int upper, double z) {
<span class="fc" id="L468">    double m1 = 0.0, m2 = 0.0;</span>
<span class="fc bfc" id="L469" title="All 2 branches covered.">    for (int k = lower; k &lt;= upper; k++) {</span>
<span class="fc" id="L470">      double p = pmfUntruncated(k) / z;</span>
<span class="fc" id="L471">      m1 += p * k;</span>
<span class="fc" id="L472">      m2 += p * (double) k * (double) k;</span>
    }
<span class="fc" id="L474">    double var = m2 - m1 * m1;</span>
<span class="pc bpc" id="L475" title="1 of 2 branches missed.">    if (var &lt; 0.0) var = 0.0;</span>
<span class="fc" id="L476">    return new double[] {m1, var};</span>
  }

  /**
   * Draws a standard {@code Normal(0,1)} using the Marsaglia polar method, with a cached &quot;spare&quot;
   * sample so every other call is essentially free.
   *
   * @return a standard normal sample
   */
  private double nextGaussian() {
<span class="fc bfc" id="L486" title="All 2 branches covered.">    if (haveSpare) {</span>
<span class="fc" id="L487">      haveSpare = false;</span>
<span class="fc" id="L488">      return spare;</span>
    }
    double u, v, s;
    do {
<span class="fc" id="L492">      u = 2.0 * rng.nextDouble() - 1.0; // (-1,1)</span>
<span class="fc" id="L493">      v = 2.0 * rng.nextDouble() - 1.0; // (-1,1)</span>
<span class="fc" id="L494">      s = u * u + v * v;</span>
<span class="pc bpc" id="L495" title="1 of 4 branches missed.">    } while (s &gt;= 1.0 || s == 0.0);</span>

<span class="fc" id="L497">    double mul = Math.sqrt(-2.0 * Math.log(s) / s);</span>
<span class="fc" id="L498">    spare = v * mul;</span>
<span class="fc" id="L499">    haveSpare = true;</span>
<span class="fc" id="L500">    return u * mul;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>